diff --git a/src/components/games/englishPuzzle/drogbleWord.js b/src/components/games/englishPuzzle/drogbleWord.js
index 89d2826..930fea1 100644
--- a/src/components/games/englishPuzzle/drogbleWord.js
+++ b/src/components/games/englishPuzzle/drogbleWord.js
@@ -1,7 +1,11 @@
 import React, { Component, useImperativeHandle } from 'react';
+import ReactDOM from 'react-dom';
 import './startPage.scss';
 import './game-puzzle.scss';
 
+let containerForPuzzles;
+let heapOfPuzzles;
+
 export class DraggableWord extends Component {
     constructor(props) {
         super(props);
@@ -12,7 +16,9 @@ export class DraggableWord extends Component {
             word: 1,
             isChecked: true,
             haveWords: false,
+            isCompleted: false,
         };
+        this.myRef = React.createRef();
     }
 
     componentDidMount() {
@@ -23,165 +29,171 @@ export class DraggableWord extends Component {
     }
 
     handleDrag = () => {
-        document.querySelectorAll('.drag-word').forEach((puzzle) => {
-            puzzle.onmousedown = (event) => {
-                const itemWidth = puzzle.getBoundingClientRect().width;
-                const itemHeight = puzzle.getBoundingClientRect().height;
-
-                const dragBlock = puzzle;
+        const puzzle = this.myRef.current;
+        puzzle.onmousedown = (event) => {
+            const itemWidth = puzzle.getBoundingClientRect().width;
+            const itemHeight = puzzle.getBoundingClientRect().height;
 
-                const containerForPuzzles = document.querySelector('.puzzle-container-sentence');
+            const dragBlock = puzzle;
 
-                const shiftX = event.clientX - puzzle.getBoundingClientRect().left;
-                const shiftY = event.clientY - puzzle.getBoundingClientRect().top;
+            const shiftX = event.clientX - puzzle.getBoundingClientRect().left;
+            const shiftY = event.clientY - puzzle.getBoundingClientRect().top;
 
-                const startX = event.clientX + window.pageXOffset;
-                const startY = event.clientY + window.pageYOffset;
+            const startX = event.clientX + window.pageXOffset;
+            const startY = event.clientY + window.pageYOffset;
 
-                const clone = puzzle.cloneNode();
-                clone.style.background = '';
+            const clone = puzzle.cloneNode();
+            clone.style.background = '';
 
-                clone.className = 'clone';
-                clone.style.width = `${itemWidth}px`;
-                clone.style.height = `${itemHeight}px`;
-                puzzle.replaceWith(clone);
+            clone.className = 'clone';
+            clone.style.width = `${itemWidth}px`;
+            clone.style.height = `${itemHeight}px`;
+            puzzle.replaceWith(clone);
 
-                dragBlock.style.position = 'absolute';
-                dragBlock.style.left = `${event.pageX - shiftX}px`;
-                dragBlock.style.top = `${event.pageY - shiftY}px`;
-                dragBlock.style.zIndex = 1000;
-                dragBlock.style.boxShadow = '0 3px 0.5rem #d9d9d9';
-                document.body.append(puzzle);
-
-                function moveAt(pageX, pageY) {
-                    dragBlock.style.left = `${pageX - shiftX}px`;
-                    dragBlock.style.top = `${pageY - shiftY}px`;
-                }
+            dragBlock.style.position = 'absolute';
+            dragBlock.style.left = `${event.pageX - shiftX}px`;
+            dragBlock.style.top = `${event.pageY - shiftY}px`;
+            dragBlock.style.zIndex = 1000;
+            dragBlock.style.boxShadow = '0 3px 0.5rem #d9d9d9';
+            document.querySelector('.puzzle-pieces').append(puzzle);
 
-                let currentWord = null;
+            function moveAt(pageX, pageY) {
+                dragBlock.style.left = `${pageX - shiftX}px`;
+                dragBlock.style.top = `${pageY - shiftY}px`;
+            }
 
-                function onMouseMove(event) {
-                    moveAt(event.pageX, event.pageY);
+            let currentWord = null;
 
-                    dragBlock.hidden = true;
-                    const elemBelow = document.elementFromPoint(event.clientX, event.clientY);
-                    dragBlock.hidden = false;
+            function onMouseMove(event) {
+                moveAt(event.pageX, event.pageY);
 
-                    if (!elemBelow) return;
+                dragBlock.hidden = true;
+                const elemBelow = document.elementFromPoint(event.clientX, event.clientY);
+                dragBlock.hidden = false;
 
-                    const droppablePazzle = elemBelow.closest('.drag-word');
-                    const droppableClone = elemBelow.closest('.clone');
+                if (!elemBelow) {
+                    return;
+                }
 
-                    if (currentWord != droppablePazzle || currentWord != droppableClone) {
+                const droppablePazzle = elemBelow.closest('.drag-word');
+                const droppableClone = elemBelow.closest('.clone');
 
-                        if (droppableClone) {
-                            return;
-                        }
+                if (currentWord != droppablePazzle || currentWord != droppableClone) {
+                    if (droppableClone) {
+                        return;
+                    }
 
-                        if (droppablePazzle && currentWord == droppablePazzle && droppablePazzle.nextElementSibling && droppablePazzle.nextElementSibling.classList.contains('clone')) {
-                            if (event.pageX >= droppablePazzle.getBoundingClientRect().left && event.pageX <= droppablePazzle.getBoundingClientRect().left + droppablePazzle.getBoundingClientRect().width / 2) {
-                                clone.remove();
-                                droppablePazzle.before(clone);
-                            }
-                            return;
+                    if (droppablePazzle && currentWord == droppablePazzle && droppablePazzle.nextElementSibling && droppablePazzle.nextElementSibling.classList.contains('clone')) {
+                        if (event.pageX >= droppablePazzle.getBoundingClientRect().left && event.pageX <= droppablePazzle.getBoundingClientRect().left + droppablePazzle.getBoundingClientRect().width / 2) {
+                            clone.remove();
+                            droppablePazzle.before(clone);
                         }
+                        return;
+                    }
 
-                        if (droppablePazzle && currentWord == droppablePazzle && droppablePazzle.previousElementSibling && droppablePazzle.previousElementSibling.classList.contains('clone')) {
-                            if (event.pageX >= droppablePazzle.getBoundingClientRect().left + (droppablePazzle.getBoundingClientRect().width / 2) && event.pageX <= droppablePazzle.getBoundingClientRect().left + droppablePazzle.getBoundingClientRect().width) {
-                                clone.remove();
-                                droppablePazzle.after(clone);
-                            }
-                            return;
+                    if (droppablePazzle && currentWord == droppablePazzle && droppablePazzle.previousElementSibling && droppablePazzle.previousElementSibling.classList.contains('clone')) {
+                        if (event.pageX >= droppablePazzle.getBoundingClientRect().left + (droppablePazzle.getBoundingClientRect().width / 2) && event.pageX <= droppablePazzle.getBoundingClientRect().left + droppablePazzle.getBoundingClientRect().width) {
+                            clone.remove();
+                            droppablePazzle.after(clone);
                         }
+                        return;
+                    }
 
-                        if (currentWord) {
-                            if (droppableClone) {
-                                return;
-                            }
-                            clone.remove();
-                            currentWord = null;
+                    if (currentWord) {
+                        if (droppableClone) {
                             return;
                         }
+                        clone.remove();
+                        currentWord = null;
+                        return;
+                    }
 
-                        currentWord = droppablePazzle;
+                    currentWord = droppablePazzle;
 
-                        if (currentWord) {
-                            if (event.pageX >= droppablePazzle.getBoundingClientRect().left && event.pageX <= droppablePazzle.getBoundingClientRect().left + droppablePazzle.getBoundingClientRect().width / 2) {
-                                droppablePazzle.before(clone);
-                            }
+                    if (currentWord) {
+                        if (event.pageX >= droppablePazzle.getBoundingClientRect().left && event.pageX <= droppablePazzle.getBoundingClientRect().left + droppablePazzle.getBoundingClientRect().width / 2) {
+                            droppablePazzle.before(clone);
+                        }
 
-                            if (event.pageX >= droppablePazzle.getBoundingClientRect().left + (droppablePazzle.getBoundingClientRect().width / 2) && event.pageX <= droppablePazzle.getBoundingClientRect().left + droppablePazzle.getBoundingClientRect().width) {
-                                droppablePazzle.after(clone);
-                            }
+                        if (event.pageX >= droppablePazzle.getBoundingClientRect().left + (droppablePazzle.getBoundingClientRect().width / 2) && event.pageX <= droppablePazzle.getBoundingClientRect().left + droppablePazzle.getBoundingClientRect().width) {
+                            droppablePazzle.after(clone);
                         }
                     }
                 }
-
-                document.addEventListener('mousemove', onMouseMove);
-
-                dragBlock.onmouseup = (event) => {
-                    document.querySelectorAll('.completed').forEach((word) => {
-                        word.classList.remove('correct-word');
-                        word.classList.remove('un-correct-word');
-                    });
-                    if (event.pageX === startX && event.pageY === startY) {
-                        containerForPuzzles.append(puzzle);
-                        puzzle.classList.add('completed');
-                        document.querySelector('.clone').outerHTML = '';
-                        dragBlock.style.position = 'static';
-                        dragBlock.style.boxShadow = '';
-                    } else if (document.querySelector('.clone') && event.pageX >= document.querySelector('.clone').getBoundingClientRect().left && event.pageX <= document.querySelector('.clone').getBoundingClientRect().left + document.querySelector('.clone').getBoundingClientRect().width && event.pageY >= document.querySelector('.clone').getBoundingClientRect().top + window.pageYOffset && event.pageY <= document.querySelector('.clone').getBoundingClientRect().top + window.pageYOffset + document.querySelector('.clone').getBoundingClientRect().height) {
-                        dragBlock.style.position = 'static';
+            }
+
+            containerForPuzzles = document.querySelector('.puzzle-container-sentence');
+            heapOfPuzzles = document.querySelector('.puzzle-pieces');
+
+            document.addEventListener('mousemove', onMouseMove);
+
+            dragBlock.onmouseup = (event) => {
+                document.querySelectorAll('.completed').forEach((word) => {
+                    word.classList.remove('correct-word');
+                    word.classList.remove('un-correct-word');
+                });
+                if (event.pageX === startX && event.pageY === startY) {
+                    /* containerForPuzzles.append(puzzle); */
+                    this.setState({ isCompleted: true });
+                    puzzle.classList.add('completed');
+                    document.querySelector('.clone').outerHTML = '';
+                    dragBlock.style.position = 'static';
+                    dragBlock.style.boxShadow = '';
+                } else if (document.querySelector('.clone') && event.pageX >= document.querySelector('.clone').getBoundingClientRect().left && event.pageX <= document.querySelector('.clone').getBoundingClientRect().left + document.querySelector('.clone').getBoundingClientRect().width && event.pageY >= document.querySelector('.clone').getBoundingClientRect().top + window.pageYOffset && event.pageY <= document.querySelector('.clone').getBoundingClientRect().top + window.pageYOffset + document.querySelector('.clone').getBoundingClientRect().height) {
+                    dragBlock.style.position = 'static';
+                    clone.replaceWith(puzzle);
+                    puzzle.classList.add('completed');
+                    dragBlock.style.boxShadow = '';
+                } else if (event.pageX >= containerForPuzzles.getBoundingClientRect().left && event.pageX <= containerForPuzzles.getBoundingClientRect().left + containerForPuzzles.getBoundingClientRect().width && event.pageY >= containerForPuzzles.getBoundingClientRect().top && event.pageY <= containerForPuzzles.getBoundingClientRect().top + window.pageYOffset + containerForPuzzles.getBoundingClientRect().height) {
+                    dragBlock.style.position = 'static';
+                    dragBlock.style.boxShadow = '';
+                    if (Array.from(containerForPuzzles.children).includes(clone)) {
                         clone.replaceWith(puzzle);
-                        puzzle.classList.add('completed');
-                        dragBlock.style.boxShadow = '';
-                    } else if (event.pageX >= containerForPuzzles.getBoundingClientRect().left && event.pageX <= containerForPuzzles.getBoundingClientRect().left + containerForPuzzles.getBoundingClientRect().width && event.pageY >= containerForPuzzles.getBoundingClientRect().top && event.pageY <= containerForPuzzles.getBoundingClientRect().top + window.pageYOffset + containerForPuzzles.getBoundingClientRect().height) {
-                        dragBlock.style.position = 'static';
-                        dragBlock.style.boxShadow = '';
-                        if (Array.from(containerForPuzzles.children).includes(clone)) {
-                            clone.replaceWith(puzzle);
-                        } else {
-                            containerForPuzzles.append(puzzle);
-                            if (clone) {
-                                clone.remove();
-                            }
-                        }
-                        puzzle.classList.add('completed');
-                    } else if (event.pageX >= document.querySelector('.puzzle-pieces').getBoundingClientRect().left && event.pageX <= document.querySelector('.puzzle-pieces').getBoundingClientRect().left + document.querySelector('.puzzle-pieces').getBoundingClientRect().width && event.pageY >= document.querySelector('.puzzle-pieces').getBoundingClientRect().top && event.pageY <= document.querySelector('.puzzle-pieces').getBoundingClientRect().top + window.pageYOffset + document.querySelector('.puzzle-pieces').getBoundingClientRect().height) {
-                        dragBlock.style.position = 'static';
-                        dragBlock.style.boxShadow = '';
-                        if (Array.from(document.querySelector('.puzzle-pieces').children).includes(clone)) {
-                            clone.replaceWith(puzzle);
-                        } else {
-                            document.querySelector('.puzzle-pieces').append(puzzle);
-                            if (clone) {
-                                clone.remove();
-                            }
+                    } else {
+                        /* containerForPuzzles.append(puzzle); */
+                        this.setState({ isCompleted: true });
+                        if (clone) {
+                            clone.remove();
                         }
-                        puzzle.classList.add('completed');
+                    }
+                    puzzle.classList.add('completed');
+                } else if (event.pageX >= heapOfPuzzles.getBoundingClientRect().left && event.pageX <= heapOfPuzzles.getBoundingClientRect().left + heapOfPuzzles.getBoundingClientRect().width && event.pageY >= heapOfPuzzles.getBoundingClientRect().top && event.pageY <= heapOfPuzzles.getBoundingClientRect().top + window.pageYOffset + heapOfPuzzles.getBoundingClientRect().height) {
+                    dragBlock.style.position = 'static';
+                    dragBlock.style.boxShadow = '';
+                    if (Array.from(heapOfPuzzles.children).includes(clone)) {
+                        clone.replaceWith(puzzle);
                     } else {
-                        if (document.querySelector('.clone')) {
-                            clone.replaceWith(puzzle);
-                        } else {
-                            document.querySelector('.puzzle-pieces').append(puzzle);
+                        /* heapOfPuzzles.append(puzzle); */
+                        this.setState({ isCompleted: false });
+                        if (clone) {
+                            clone.remove();
                         }
-                        dragBlock.style.position = 'static';
-                        dragBlock.style.boxShadow = '';
                     }
-                    document.removeEventListener('mousemove', onMouseMove);
-                    dragBlock.onmouseup = null;
-                    this.checkSentence();
-                };
+                    puzzle.classList.add('completed');
+                } else {
+                    if (document.querySelector('.clone')) {
+                        clone.replaceWith(puzzle);
+                    } else {
+                        /* heapOfPuzzles.append(puzzle); */
+                        this.setState({ isCompleted: false });
+                    }
+                    dragBlock.style.position = 'static';
+                    dragBlock.style.boxShadow = '';
+                }
+                document.removeEventListener('mousemove', onMouseMove);
+                dragBlock.onmouseup = null;
+                this.checkSentence();
             };
-        });
+        };
     }
 
     checkSentence = () => {
-        const puzzleField = document.querySelector('.puzzle-pieces');
+        const puzzleField = heapOfPuzzles;
         if (!puzzleField.innerHTML) {
             // this.props.showCheck(true);
             this.props.showButton('isCheckBtn', true);
             this.props.showButton('isDontKnowBtn', false);
+            this.forceUpdate();
         } else {
             // this.props.showCheck(false);
             this.props.showButton('isCheckBtn', false);
@@ -190,7 +202,9 @@ export class DraggableWord extends Component {
 
     render() {
         return (
-            <div className="drag-word"><span className="word-text">{this.props.word}</span></div>
+            this.state.isCompleted
+                ? ReactDOM.createPortal(<div ref={this.myRef} className="drag-word KOLBASA"><span className="word-text">{this.props.word}</span></div>, containerForPuzzles)
+                : <div ref={this.myRef} className="drag-word"><span className="word-text">{this.props.word}</span></div>
         );
     }
 }
